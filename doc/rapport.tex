\documentclass[12pt, openany]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\usepackage{lingmacros}
\usepackage{mdframed}
\usepackage[latin1]{inputenc}
\usepackage[francais]{babel}
\usepackage{tree-dvips}
\usepackage{tikz}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{fancyvrb}
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@verbatim}
  {\verbatim@font}
  {\verbatim@font\tiny}
  {}{}
\makeatother
\begin{document}
\begin{titlepage}
  \begin{sffamily}
  \begin{center}
    \includegraphics[scale=1]{img/logo-ub.png}~\\[1.5cm]
    \textsc{\LARGE Université de Bourgogne}\\[2cm]
    \textsc{\Large Rapport de projet}\\[1.5cm]
    \HRule \\[0.4cm]
    { \huge \bfseries Algorithmique et Complexité\\[0.4cm] }
    \HRule \\[2cm]
    \includegraphics[scale=1]{img/logo-ufr.png}
    \\[2cm]
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        BELDILMI \textsc{Guillaume}\\
        GENCE \textsc{Elio}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Tuteur :} RAFFIN \textsc{Romain}\\
      \end{flushright}
    \end{minipage}
    \vfill
    {\large 2024}
  \end{center}
  \end{sffamily}
\end{titlepage}
\section*{Présentation du projet}

Eternity II est un jeu de puzzle inventé par Christopher Monckton en
2007. Le but du jeu est de placer des pièces de puzzle de manière à
ce que les couleurs des bords des pièces soient identiques aux
couleurs des bords adjacents.  Les pièces sont carrées et chaque
côté est coloré. Les pièces sont placées sur une grille de taille
$n \times n$.

Notre projet était de créer un solveur capable de résoudre des
puzzles d’Eternity II de taille 12 par 12 avec une dizaine de
couleurs. Nos seules contraintes étaient que notre programme devait
être écrit en Ocaml et que la résolution devait se faire par une
méthode de recherche arborescente avec retour en arrière (backtrack).

Pour cela, nous avons divisé le projet en plusieurs étapes :
tout d’abord, nous avons créé une structure de données pour
représenter les pièces et la grille. Ensuite, nous avons créé un
ensemble de fonctions permettant de générer un puzzle aléatoire,
de mélanger les pièces du puzzle, et enfin de résoudre le puzzle.
A cela s’ajoute une autre fonction permettant d'afficher le puzzle
afin d'avoir un retour sur l'exécution du programme.

\section*{Organisation}

Premièrement, nous avons réalisé un prototype conformément à
l'ISO-1664 dans un langage plus abordable, Python. Ce prototype
nous a permis de mieux comprendre le problème et de définir
l'architecture de notre programme.

Ensuite, nous avons transcrit ce prototype en Ocaml, en corrigeant
quelques erreurs et en ajoutant des fonctionnalités précédemment
omises après avoir pris en compte le retour du corps enseignant.

Nous avons ensuite testé notre programme sur des puzzles
progressivement de plus en plus grands.

Enfin, nous avons peaufiné notre programme en simplifiant le code
et en corrigeant l'affichage du puzzle afin de rendre le résultat
plus facile à manipuler.

\subsection*{Explication de l'algorithme utilisé}

Nous avons utilisé un algorithme naïf de backtracking pour résoudre
le puzzle. L’idée est de placer chaque pièce sur la grille en
progressant selon le sens d’écriture. Si une pièce ne peut pas être
placée, on revient à la pièce précédemment placée et on essaie une
autre pièce. Si aucune pièce ne peut être placée, on revient à la
pièce précédente, et ainsi de suite jusqu’à ce que le puzzle soit
résolu. Une fois le puzzle résolu, on affiche le résultat et puis
le programme poursuit son exécution afin de trouver d'autres
solutions. 

D'autres algorithmes plus performants existent, optimisants notamment
l'ordre de placement des pièces (commençant par les pièces de bords
puis progressant vers le centre en zigzag ou en spirale), mais nous
avons choisi de rester sur un algorithme simple pour des raisons de
simplicité et de temps.

\subsection*{Analyse de la complexité}


\section*{Détails techniques}
% Détails pertinents de l'implémentation
% points durs, organisation,
% structures de données


\section*{Résultats et analyses}

Voici un exemple de puzzle de taille 5 par 5 avec 3 couleurs résolu
par notre programme :

\begin{verbnobox}\fontsize{7pt}{7pt}\selectfont
  \VerbatimInput{demo_5_3.txt}
\end{verbnobox}








\section*{Conclusion}
% une conclusion qui établit (ou non) en justifiant le lien entre votre implé-
% mentation et l’analyse théorique de l’algorithme

\end{document}
